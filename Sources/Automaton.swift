//
//  Automaton.swift
//  ReactiveAutomaton
//
//  Created by Yasuhiro Inami on 2016-05-07.
//  Copyright Â© 2016 Yasuhiro Inami. All rights reserved.
//

import Result
import ReactiveCocoa

public protocol StateType {}
public protocol InputType {}

/// Deterministic finite automaton.
public final class Automaton<State: StateType, Input: InputType>
{
    /// Basic state-transition function type.
    public typealias Mapping = (State, Input) -> State?

    /// Transducer (input & output) mapping with `SignalProducer<Input, NoError>` as "next producer" output,
    /// which can wrap heavy tasks and emit **next input values**
    /// for automatic & continuous state-transitions.
    public typealias NextMapping = (State, Input) -> (State, SignalProducer<Input, NoError>)?

    /// `Reply` signal.
    public let replies: Signal<Reply<State, Input>, NoError>

    /// Current state.
    public let state: AnyProperty<State>

    private let _replyObserver: Observer<Reply<State, Input>, NoError>

    private var _disposable: Disposable?

    ///
    /// Initializer using `Mapping`.
    ///
    /// - Parameters:
    ///   - state: Initial state.
    ///   - input: `Signal<Input, NoError>` that automaton receives.
    ///   - mapping: Simple `Mapping` that designates next state only (no next input-producer).
    ///
    public convenience init(state initialState: State, input inputSignal: Signal<Input, NoError>, mapping: Mapping)
    {
        self.init(state: initialState, input: inputSignal, mapping: _compose(_toNextMapping, mapping))
    }

    ///
    /// Initializer using `NextMapping`.
    ///
    /// - Parameters:
    ///   - state: Initial state.
    ///   - input: `Signal<Input, NoError>` that automaton receives.
    ///   - mapping: `NextMapping` that designates next state and also generates next input-producer.
    ///   - strategy: `FlattenStrategy` that flattens next input-producer generated by `NextMapping`.
    ///
    public init(state initialState: State, input inputSignal: Signal<Input, NoError>, mapping: NextMapping, strategy: FlattenStrategy = .Merge)
    {
        let stateProperty = MutableProperty(initialState)
        self.state = AnyProperty(stateProperty)

        (self.replies, self._replyObserver) = Signal<Reply<State, Input>, NoError>.pipe()

        /// Recursive input-producer that sends inputs from `inputSignal`
        /// and also next producers generated by `NextMapping`.
        func recurInputProducer(inputProducer: SignalProducer<Input, NoError>, strategy: FlattenStrategy) -> SignalProducer<Input, NoError>
        {
            return SignalProducer<Input, NoError> { observer, disposable in
                inputProducer
                    .sampleFrom(stateProperty.producer)
                    .map { input, fromState in
                        return (input, fromState, mapping(fromState, input)?.1)
                    }
                    .startWithSignal { mappingSignal, mappingSignalDisposable in
                        //
                        // NOTE:
                        // `mergedProducer` (below) doesn't emit `.Interrupted` although `mappingSignal` sends it,
                        // so propagate it to returning producer manually.
                        //
                        disposable += mappingSignal.observeInterrupted {
                            observer.sendInterrupted()
                        }

                        //
                        // NOTE:
                        // Split `mappingSignal` into `successSignal` and `failureSignal` (and merge later) so that
                        // inner producers of `flatMap(strategy)` in `successSignal` don't get interrupted by mapping failure.
                        //
                        let successSignal = mappingSignal
                            .filterMap { input, fromState, nextProducer in
                                return nextProducer.map { (input, fromState, $0) }
                            }
                            .flatMap(strategy) { input, fromState, nextProducer -> SignalProducer<Input, NoError> in
                                return recurInputProducer(nextProducer, strategy: strategy)
                                    .prefix(value: input)
                            }

                        let failureSignal = mappingSignal
                            .filterMap { input, fromState, nextProducer -> Input? in
                                return nextProducer == nil ? input : nil
                            }

                        let mergedProducer = SignalProducer(values: failureSignal, successSignal).flatten(.Merge)

                        disposable += mergedProducer.start(observer)
                        disposable += mappingSignalDisposable
                    }
            }
        }

        recurInputProducer(SignalProducer(signal: inputSignal), strategy: strategy)
            .sampleFrom(stateProperty.producer)
            .flatMap(.Merge) { input, fromState -> SignalProducer<Reply<State, Input>, NoError> in
                if let (toState, _) = mapping(fromState, input) {
                    return .init(value: .Success(input, fromState, toState))
                }
                else {
                    return .init(value: .Failure(input, fromState))
                }
            }
            .startWithSignal { replySignal, disposable in
                self._disposable = disposable

                stateProperty <~ replySignal
                    .flatMap(.Merge) { reply -> SignalProducer<State, NoError> in
                        if let toState = reply.toState {
                            return .init(value: toState)
                        }
                        else {
                            return .empty
                        }
                    }

                replySignal.observe(self._replyObserver)
            }
    }

    deinit
    {
        self._replyObserver.sendCompleted()
        self._disposable?.dispose()
    }
}

// MARK: Private

private func _compose<A, B, C>(g: B -> C, _ f: A -> B) -> A -> C
{
    return { x in g(f(x)) }
}

private func _toNextMapping<State: StateType, Input: InputType>(toState: State?) -> (State, SignalProducer<Input, NoError>)?
{
    if let toState = toState {
        return (toState, .empty)
    }
    else {
        return nil
    }
}
